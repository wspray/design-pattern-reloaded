设计模式的六大原则
1.单一职责原则（Single Responsibility Principle）
原则思想：一个方法只负责一件事情。
 描述：单一职责原则很简单，一个方法 一个类只负责一个职责，各个职责的程序改动，不影响其它程序。 这是常识，几乎所有程序员都会遵循这个原则。
 优点：降低类和类的耦合，提高可读性，增加可维护性和可拓展性，降低可变性的风险。
2.开放封闭原则（Open-Closed Principle）
  原则思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化
   描述：一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。
   优点：单一原则告诉我们，每个类都有自己负责的职责，里氏替换原则不能破坏继承关系的体系。
3.里氏替换原则（Liskov Substitution Principle）
  原则思想：使用的基类可以在任何地方使用继承的子类，完美的替换基类。（子类可安全的替换父类）
   描述：子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法。
   优点：增加程序的健壮性，即使增加了子类，原有的子类还可以继续运行，互不影响。
   isAssignableFrom：可转让给 （用于检查一个类是否与另一个类兼容，即是否可以将一个类的对象赋值给另一个类的引用。）
4.接口隔离原则（Interface Segregation Principle）
原则思想：类和类之间应该建立在最小接口的上。
 描述：类A通过接口依赖B，类C通过接口依赖D，如果接口类A和类B不是最小的接口，则依赖的类B和类D必须要实现他们不需要的方法。
 优点：提高程序的灵活度，提高内聚，减少对外交互，使得最小的接口做最多的事情。
5.依赖倒置原则（Dependency Inversion Principle）
  原则思想：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象，抽象不应该依赖于具体实现，具体实现应该依赖于抽象。
   描述：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。
   优点：可以减少需求变化带来的工作量，做并行开发更加友好。
 优点：低耦合，高内聚。
6.迪米特法则（最少知识原则，Law of Demeter）
  原则思想：一个对象应当对其他对象有尽可能少地了解，简称类间解耦
   描述：一个类尽量减少自己对其他对象的依赖，原则是低耦合，高内聚，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。
记忆方法：solid 稳定的 各个模式的英文首字母